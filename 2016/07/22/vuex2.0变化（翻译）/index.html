<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> issue vuex2.0 变化（翻译） · ddddup</title><meta name="description" content="issue vuex2.0 变化（翻译） - ddddup"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">issue vuex2.0 变化（翻译）</h1><div class="post-time">Jul 22, 2016</div><div class="post-content"><p>原文链接：<a href="https://github.com/vuejs/vuex/issues/236" target="_blank" rel="external">https://github.com/vuejs/vuex/issues/236</a></p>
<p>###1. 术语命名的变化让使其更加语义化</p>
<p>Dispatching一个mutation听起来不是很正确。Dispatch应该表示某件事情发生的意向。而对于mutations，我们需要一个动词用来表示一旦调用它就会发生状态的修改。</p>
<ul>
<li>老版本调用<code>store.dispatch</code> 现在改为使用<code>store.commit</code>。</li>
<li><code>store.dispatch</code> 将用于触发actions动作。（参见下节说明）</li>
</ul>
<p>新的命名更好的传达了两种方法背后的语义：</p>
<ul>
<li>“dispatching an action”: 表明某些事件发生的意向（可能是异步操作产生的副作用）</li>
<li>“committing a mutation”: 说明会使实际状态发生改变的同步操作</li>
</ul>
<p>###2. 模块可移植性 &amp; 可组合性</p>
<h5 id="store和modules中的actions"><a href="#store和modules中的actions" class="headerlink" title="store和modules中的actions"></a>store和modules中的actions</h5><p>在store的actions或者是modules内部可以设置通用的请求，以前，在store/modules不设置多个actions的原因是：我们如何去访问他们。actions定义在store里面的意味着我们需要访问store - 再次说明下，这是个单例问题，现在不存在这个问题。</p>
<p>现在它们只是函数，我们可以将它们对外提供action.actions并且可以直接访问。实际上这个API已经在Vuex 0.4.x提供：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store.xxx <span class="comment">// reserved for Store class methods/properties</span></span><br><span class="line">store.actions.xxx <span class="comment">// this seems ok</span></span><br></pre></td></tr></table></figure>
<p>问题是当actions定义在modules内时，如果多个modules定义了同名的actions怎么处理？有时候我们想调用action去出发多个stores，就像mutations一样。</p>
<p>看起来actions更像事件监听器，但不是直接使用函数来直接调用，我们现在使用<code>store.dispatch</code>来触发它们。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    doSomething: (&#123; commit &#125;) =&gt; &#123;</span><br><span class="line">      commit(<span class="string">'some-mutation'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(<span class="string">'doSomething'</span>)</span><br></pre></td></tr></table></figure>
<p>通过这种方式，你可以使用一个调用在多个modules中dispatch actions，就和操作mutations一样。这样相比在store中引起一些副作用会更加明确，而不是只调用一个随机的函数。</p>
<h5 id="Getters-也是一样"><a href="#Getters-也是一样" class="headerlink" title="Getters 也是一样"></a>Getters 也是一样</h5><p>你现在也可以在store/modules中定义getters。与mutations模块类似，getters模块接收一个子状态树：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    hasAny: state =&gt; state.count &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// access the getter</span></span><br><span class="line">store.getters.hasAny <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-组合Action流程"><a href="#3-组合Action流程" class="headerlink" title="3. 组合Action流程"></a>3. 组合Action流程</h3><p>现在我们在模块内部配置actions，并通过<code>dispatch</code>调用它们，但这样我们就失去了actions的可组合性，因为它们不再是可以直接调用的方法了。下面我们将介绍如何能让它们再次具备可组合性：</p>
<ol>
<li>表明action的完成，action返回一个Promise对象。如果只有一个handler被调用，<code>store.dispatch</code> 将返回该Promise对象。如果有多个actions handler匹配，它将返回一个Promise,当这些handlers的所有Promise都resolved。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    doSomething: (&#123; commit &#125;, payload) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> callPromiseAPI(payload).then(res =&gt; &#123;</span><br><span class="line">         commit(<span class="string">'some-mutation'</span>, &#123; res &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(<span class="string">'doSomething'</span>, &#123; id: <span class="number">1</span> &#125;).then(() =&gt; &#123;</span><br><span class="line">  <span class="comment">// action done</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>在(1)的基础上使用<code>async/await</code>，我们可以非常清晰的在异步actions之间进行组合</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    one: <span class="keyword">async</span> (&#123; commit &#125;, payload) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> callPromiseAPI(payload)</span><br><span class="line">      commit(<span class="string">'some-mutation'</span>, &#123; res &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    two: <span class="keyword">async</span> (&#123; dispatch, commit &#125;) =&gt; &#123;</span><br><span class="line">      <span class="keyword">await</span> dispatch(<span class="string">'one'</span>)</span><br><span class="line">      commit(<span class="string">'done'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(<span class="string">'two'</span>) <span class="comment">// fires off complicated async flow</span></span><br></pre></td></tr></table></figure>
<p>返回promise的规范也允许vuex：</p>
<ol>
<li>在异步action流程中更好的进行错误处理</li>
<li>简化服务端渲染时store初始化操作</li>
</ol>
<h3 id="组件绑定"><a href="#组件绑定" class="headerlink" title="组件绑定"></a>组件绑定</h3><p>Vuex0.6~1.0版本的设计上有一些特殊的设计约束：避免直接在组件内部访问store。store是通过根组件注入，并通过属性<code>vuex: { getters, actions }</code>隐式的使用。这是为Vue2.0 SSR（服务端渲染）做准备，因为在通常的SSR设置(直接在node.js中引用组件并渲染它)。依赖一个全局的单例模型，这将导致这个单例在多个请求之间共享，因此可能导致一个请求污染下一个请求的状态。</p>
<p>然而，在Vue2.0.0-alpha.7中实现了新的<code>bundleRenderer</code>策略，这已经不在是一个问题。应用程序bundle将在每个请求中运行一个新的上下文。使得有必要重新结构化你的app代码，而不是单单只是为了SSR。<br>这也意味着类似<code>import store from &#39;./store</code>，使用简单的计算属性返回<code>store.state.xxx</code>，或者在普通方法中调用<code>store.dispatch()</code>是完全正确的.</p>
<p>这开启了简化组件绑定使用的途径，因为理论上你根本不需要任何绑定。 目前，vuex属性感觉有些笨拙隐晦。</p>
<p>在Vuex2.0中，<code>vuex</code>属性将被弃用，取而代之的是使用计算属性和方法，你可以按自己喜欢的方式自由的构建Vuex store。然而，我们需要确保<code>this.$store</code> 被注入，使你能这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    a () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.a</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    b (...args) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.dispatch(<span class="string">'b'</span>, …args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中任何地方我们需要引用store，但是当你在一个组件中有很多getters和actions时，编写代码时会显得有点麻烦，因此我们提供了2个帮助方法，<code>mapGetters</code>和<code>mapActions</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: mapGetters([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),</span><br><span class="line">  methods: mapActions([<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样在组件中，<code>this.a</code> 映射 <code>this.$store.gettings.a</code>， <code>this.d(...args)</code> 映射 <code>this.$store.dispatch(&#39;d&#39;,...args)</code>。</p>
<p>如果你想给getter/action映射一个不一样的名字，可以使用一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: mapGetters(&#123;</span><br><span class="line">    myComputed: <span class="string">'a'</span> // map this.myComputed to store.getters.a</span><br><span class="line">  &#125;),</span><br><span class="line">  methods: mapActions(&#123;</span><br><span class="line">    myMethod: <span class="string">'b'</span> // map this.myMethod() to store.dispatch(<span class="string">'b'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，你可以使用es6的对象扩展轻松的将它们和本地的计算属性和方法组合。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    localComputed () &#123; … &#125;,</span><br><span class="line">    ...mapGetters([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    localMethod () &#123; … &#125;,</span><br><span class="line">    ...mapActions([<span class="string">'b'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/07/javascript函数式编程入门/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">ddddup</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>